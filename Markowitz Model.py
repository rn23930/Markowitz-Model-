# -*- coding: utf-8 -*-
"""Assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16NVoreSk7-e8uGanBv4XvhnebbfKqRuY

# **Task 1**

# Implementation of Markowitz portfolio optimisation on problem given.Solver used is 'Gurobipy'
"""

pip install gurobipy

# importing necessary libraries such as Numpy for numerical calculations,
# for plotting results and curve Matplotlib
# random is used for generating random numbers
# and gurobipy for optimization problem solving

import numpy as np
import random
import matplotlib.pyplot as plt
from gurobipy import Model , GRB , quicksum

# A function is defined for creating a optimization model.
# A variable 'x' is used for representing weights of each assets in the portfolio.

def Markowitz_Portfolio_Optimization(Mu , Cov_Matrix , Target_Return):
# This function take input as defined in it and return  weights volatility and expected return
# Mu is return and Cov_Matrix is used for covariance matrix.

  assets = len(Mu)

  model = Model("MarkowitzPortfolioOptimization")

  x = model.addVars(assets , vtype= GRB.CONTINUOUS , name='weight')
  # addVars add multiple decision variables.
  # It returns a gurobi tupledict object that contains a newly created variables

  model.setObjective(quicksum(quicksum(Cov_Matrix[i , j]*x[i]*x[j] for i in range (assets)) for j in range(assets)),sense=GRB.MINIMIZE)
  # setObjective function is used to set the model objective equal to linear or quadratic expression.
  # The objective function is set to minimize the portfolio variance defined using covariance matrix and variable 'x'.

  model.addConstr(quicksum(Mu[i] * x[i] for i in range(assets)) == Target_Return, "Target_Return")
  model.addConstr(quicksum(x[i] for i in range(assets)) == 1, "Budget_Constraint")
  # model.addConstr is used to add constraints to a model.
  # First contraint reflects that weighted sum of expected return is equal to target return.
  # Second contraint shows that sum of weights is 1 i.e. fully invested portfolio.

  for i in range(assets):
    model.addConstr(x[i] >= 0, f"non_negative_{i}")
    # another contraint is added for defining the boundaris and ensuring that weights are non-negative.

    model.optimize()

    weights = np.array([x[i].x for i in range(assets)]) # getting optimal weights

    return weights, np.sqrt(weights @ Cov_Matrix @ weights), weights @ Mu
     # here we get optimal weights, volatility,expected return and return.
np.random.seed(42)

d1 = 6
d2 = 2

dummystep = 10 * d1 + d2
for _ in range(dummystep):
    dummy = random.uniform(0, 1)

n = 8
Corr = np.array([[0] * n for _ in range(n)], dtype=float)

for i in range(n):
    for j in range(n):
        Corr[i][j] = (-1) ** abs(i - j) / (abs(i - j) + 1)
        # 8x8 correlation matrix is generated

ssigma = np.array([[0] * 1 for _ in range(n)], dtype=float)
mmu = np.array([[0] * 1 for _ in range(n)], dtype=float)

ssigma[0] = 2
mmu[0] = 3

for i in range(n - 1):
    ssigma[i + 1] = ssigma[i] + 2 * random.uniform(0, 1)
    mmu[i + 1] = mmu[i] + 1
  # ssigma and mmu arrays are created for storing volatility and expected return values of assets.
ddiag = np.array([[0] * n for _ in range(n)], dtype=float)
np.fill_diagonal(ddiag, ssigma)
C2 = np.matmul(np.matmul(ddiag, Corr), ddiag)
C = 0.5 * (C2 + C2.T)
# using volatility values a diagonal matrix is created
# A covariance matrix 'C' is created using correlation matrix.


# Now the Markowitz optimization will be performed on different values of 'r' given.
r = np.arange(3.00, 9.25, 0.25)
sigma_values = []
Mu_values = []

for r in r:
    weights, sigma, Mu = Markowitz_Portfolio_Optimization(mmu.flatten(), C, r)
    sigma_values.append(sigma)
    Mu_values.append(Mu)

    # here the loop iterates over different values of 'r' as given in problem statement and solves Markowitz Portfolio Optimization.
    # The weights, volatility, and expected return are stored in sigma_values and Mu_values.

plt.figure(figsize=(10, 6))
plt.scatter(sigma_values, Mu_values, label='Markowitz Portfolio', color='blue')
plt.title('Markowitz Portfolio Optimization:Efficient Frontier',color='brown')
plt.xlabel('Portfolio Volatility (σ)')
plt.ylabel('Portfolio Expected Return (μ)')
plt.legend()
plt.grid(True)
plt.show()

"""****************************************************************************************************************************************************************

---

# Task 2

# For Task 2, instead of investing whole capital, a fraction of it is kept uninvested without any return or risk.
"""

# importing necessary libraries required

import numpy as np
import random
import matplotlib.pyplot as plt
from gurobipy import Model , GRB , quicksum

# A modified Markowitz function is defined
def modified_Markowitz_Portfolio_Optimization(Mu , Cov_Matrix , Target_Return):
  assets = len(Mu)

  model = Model("modifiedMarkowitzPortfolioOptimization")

  x = model.addVars(assets , vtype= GRB.CONTINUOUS , name='weight')

  model.setObjective(quicksum(quicksum(Cov_Matrix[i , j]*x[i]*x[j] for i in range (assets)) for j in range(assets)),sense=GRB.MINIMIZE)

  model.addConstr(quicksum(Mu[i] * x[i] for i in range(assets)) == Target_Return, "Target_Return")
  model.addConstr(quicksum(x[i] for i in range(assets)) <= 1, "Budget_Constraint")
  # First contraint remains same as in task 1.
  # Second contraint is modified and shows that sum of weights is less than or equal to  1.

  for i in range(assets):
    model.addConstr(x[i] >= 0, f"non_negative_{i}")
    # another contraint is added for defining the boundaris and ensuring that weights are non-negative.

    model.optimize()

    weights = np.array([x[i].x for i in range(assets)]) # getting optimal weights

    return weights, np.sqrt(weights @ Cov_Matrix @ weights), weights @ Mu
     # here we get optimal weights, volatility,expected return and return.

np.random.seed(42)

d1 = 6
d2 = 2

dummystep = 10 * d1 + d2
for _ in range(dummystep):
    dummy = random.uniform(0, 1)

n = 8
Corr = np.array([[0] * n for _ in range(n)], dtype=float)

for i in range(n):
    for j in range(n):
        Corr[i][j] = (-1) ** abs(i - j) / (abs(i - j) + 1)
        # 8x8 correlation matrix is generated

ssigma = np.array([[0] * 1 for _ in range(n)], dtype=float)
mmu = np.array([[0] * 1 for _ in range(n)], dtype=float)

ssigma[0] = 2
mmu[0] = 3

for i in range(n - 1):
    ssigma[i + 1] = ssigma[i] + 2 * random.uniform(0, 1)
    mmu[i + 1] = mmu[i] + 1
  # ssigma and mmu arrays are created for storing volatility and expected return values of assets.

ddiag = np.array([[0] * n for _ in range(n)], dtype=float)
np.fill_diagonal(ddiag, ssigma)
C2 = np.matmul(np.matmul(ddiag, Corr), ddiag)
C = 0.5 * (C2 + C2.T)
# using volatility values a diagonal matrix is created
# A covariance matrix 'C' is created using correlation matrix.


# Now the Markowitz optimization will be performed on different values of 'r' given.
r = np.arange(3.00, 9.25, 0.25)
sigma_values_modified = []
Mu_values_modified = []

for r in r:
    weights, sigma, Mu = modified_Markowitz_Portfolio_Optimization(mmu.flatten(), C, r)
    sigma_values_modified.append(sigma)
    Mu_values_modified.append(Mu)

    # here the loop iterates over different values of 'r' as given in problem statement and solves Markowitz Portfolio Optimization.
    # The weights, volatility, and expected return are stored in sigma_values_modified and Mu_values_modified.

plt.figure(figsize=(10, 6))
plt.scatter(sigma_values_modified, Mu_values_modified, label='Modified Markowitz Portfolio', color='green')
plt.title('Modified Markowitz Portfolio Optimization',color='red')
plt.xlabel('Portfolio Volatility (σ)')
plt.ylabel('Portfolio Expected Return (μ)')
plt.legend()
plt.grid(True)
plt.show()

"""****************************************************************************************************************************************************************


---

# **Task 3**

# In Task 1, constraint used for target return is defined as 𝝁𝑇𝒙 = 𝑟. Now for Task 3 this constraint is changed to 𝝁𝑇𝒙 >= 𝑟
"""

# importing required libraries

import numpy as np
import random
import matplotlib.pyplot as plt
from gurobipy import Model , GRB , quicksum

# A modified function is defined for creating a optimization model.

def Modified_Markowitz_Portfolio_Optimization(Mu , Cov_Matrix , Target_Return):

  assets = len(Mu)

  model = Model("ModifiedMarkowitzPortfolioOptimization")

  x = model.addVars(assets , vtype= GRB.CONTINUOUS , name='weight')

  model.setObjective(quicksum(quicksum(Cov_Matrix[i , j]*x[i]*x[j] for i in range (assets)) for j in range(assets)),sense=GRB.MINIMIZE)

  model.addConstr(quicksum(Mu[i] * x[i] for i in range(assets)) >= Target_Return, "Target_Return")
  model.addConstr(quicksum(x[i] for i in range(assets)) == 1, "Budget_Constraint")
  # model.addConstr is used to add constraints to a model.
  # First contraint reflects that weighted sum of expected return is greater than and equal to target return.
  # Second contraint shows that sum of weights is 1 i.e. fully invested portfolio.

  for i in range(assets):
    model.addConstr(x[i] >= 0, f"non_negative_{i}")
    # another contraint is added for defining the boundaris and ensuring that weights are non-negative.

    model.optimize()

    weights = np.array([x[i].x for i in range(assets)]) # getting optimal weights

    return weights, np.sqrt(weights @ Cov_Matrix @ weights), weights @ Mu
     # here we get optimal weights, volatility,expected return and return.
np.random.seed(42)

d1 = 6
d2 = 2

dummystep = 10 * d1 + d2
for _ in range(dummystep):
    dummy = random.uniform(0, 1)

n = 8
Corr = np.array([[0] * n for _ in range(n)], dtype=float)

for i in range(n):
    for j in range(n):
        Corr[i][j] = (-1) ** abs(i - j) / (abs(i - j) + 1)
        # 8x8 correlation matrix is generated

ssigma = np.array([[0] * 1 for _ in range(n)], dtype=float)
mmu = np.array([[0] * 1 for _ in range(n)], dtype=float)

ssigma[0] = 2
mmu[0] = 3

for i in range(n - 1):
    ssigma[i + 1] = ssigma[i] + 2 * random.uniform(0, 1)
    mmu[i + 1] = mmu[i] + 1
  # ssigma and mmu arrays are created for storing volatility and expected return values of assets.
ddiag = np.array([[0] * n for _ in range(n)], dtype=float)
np.fill_diagonal(ddiag, ssigma)
C2 = np.matmul(np.matmul(ddiag, Corr), ddiag)
C = 0.5 * (C2 + C2.T)
# using volatility values a diagonal matrix is created
# A covariance matrix 'C' is created using correlation matrix.


# Now the Markowitz optimization will be performed on different values of 'r' given.
r = np.arange(3.00, 9.25, 0.25)
sigma_values_Modified = []
Mu_values_Modified = []

for r in r:
    weights, sigma, Mu = Modified_Markowitz_Portfolio_Optimization(mmu.flatten(), C, r)
    sigma_values_Modified.append(sigma)
    Mu_values_Modified.append(Mu)

    # here the loop iterates over different values of 'r' as given in problem statement and solves Markowitz Portfolio Optimization.
    # The weights, volatility, and expected return are stored in sigma_values_Modified and Mu_values_Modified.

plt.figure(figsize=(10, 6))
plt.scatter(sigma_values_Modified, Mu_values_Modified, label='Modified Markowitz Portfolio', color='orange')
plt.title('Modified Markowitz Portfolio Optimization:Task 3',color='magenta')
plt.xlabel('Portfolio Volatility (σ)')
plt.ylabel('Portfolio Expected Return (μ)')
plt.legend()
plt.grid(True)
plt.show()

"""****************************************************************************************************************************************************************


---

# **Task 4**

# Short Selling

System is modelled by removing constraint x>=0.
"""

# importing required libraries

import numpy as np
import random
import matplotlib.pyplot as plt
from gurobipy import Model , GRB , quicksum

# A function for short selling is defined
def Short_Selling_Portfolio_Optimization(Mu , Cov_Matrix , Target_Return):

  assets = len(Mu)

  model = Model("ShortSellingPortfolioOptimization")

  x = model.addVars(assets , vtype= GRB.CONTINUOUS , name='weight')
  # addVars add multiple decision variables.

  model.setObjective(quicksum(quicksum(Cov_Matrix[i , j]*x[i]*x[j] for i in range (assets)) for j in range(assets)),sense=GRB.MINIMIZE)
  # The objective function is set to minimize the portfolio variance defined using covariance matrix and variable 'x'.

  model.addConstr(quicksum(Mu[i] * x[i] for i in range(assets)) == Target_Return, "Target_Return")
  model.addConstr(quicksum(x[i] for i in range(assets)) == 1, "Budget_Constraint")
  # model.addConstr is used to add constraints to a model.
  # First contraint reflects that weighted sum of expected return is equal to target return.
  # Second contraint shows that sum of weights is 1 i.e. fully invested portfolio.

  model.optimize()

  weights = np.array([x[i].x for i in range(assets)]) # getting optimal weights

  return weights, np.sqrt(weights @ Cov_Matrix @ weights), weights @ Mu
     # here we get optimal weights, volatility,expected return and return.
np.random.seed(42)

n = 8
Corr = np.array([[(-1) ** abs(i - j) / (abs(i - j) + 1) for j in range(n)] for i in range(n)], dtype=float)
ssigma = np.cumsum(2 * np.random.rand(n))
mmu = np.cumsum(1 + np.random.rand(n))

ddiag = np.diag(ssigma)
C2 = np.dot(np.dot(ddiag, Corr), ddiag)
C = 0.5 * (C2 + C2.T)


r = np.arange(3.00, 9.25, 0.25)

sigma_values_short_selling = []
Mu_values_short_selling = []

for r in r:
    weights, sigma, Mu = Short_Selling_Portfolio_Optimization(mmu.flatten(), C, r)
    sigma_values_short_selling.append(sigma)
    Mu_values_short_selling.append(Mu)


plt.figure(figsize=(10, 6))
plt.scatter(sigma_values_short_selling, Mu_values_short_selling, label='Short Selling Portfolio', color='Purple')
plt.title('Short Selling Portfolio Optimization',color='maroon')
plt.xlabel('Portfolio Volatility (σ)')
plt.ylabel('Portfolio Expected Return (μ)')
plt.legend()
plt.grid(True)
plt.show()

